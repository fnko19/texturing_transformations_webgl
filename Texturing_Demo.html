<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL Texturing Demo - Textured Rotating Cube</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }
      .container {
        background: white;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        max-width: 800px;
        width: 100%;
      }
      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 10px;
      }
      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 20px;
        font-size: 14px;
      }
      canvas {
        border: 3px solid #667eea;
        border-radius: 10px;
        display: block;
        margin: 20px auto;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }
      .info {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        border-left: 4px solid #667eea;
      }
      .info h3 {
        margin-top: 0;
        color: #667eea;
      }
      .info ul {
        margin: 10px 0;
        padding-left: 20px;
      }
      .info li {
        margin: 5px 0;
        color: #555;
      }
      .status {
        text-align: center;
        padding: 10px;
        background: #e8f5e9;
        border-radius: 5px;
        color: #2e7d32;
        font-weight: bold;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸŽ¨ WebGL Texturing Demo</h1>
      <div class="subtitle">Demonstrasi Texture Mapping pada Rotating Cube</div>

      <canvas id="glCanvas" width="640" height="640"></canvas>

      <div id="status" class="status">Loading texture...</div>

      <div class="info">
        <h3>Konsep yang Didemonstrasikan:</h3>
        <ul>
          <li>
            <strong>Texture Object:</strong> Texture dibuat dan di-bind ke WebGL
            context
          </li>
          <li>
            <strong>Texture Unit:</strong> Menggunakan gl.TEXTURE0 untuk
            sampling
          </li>
          <li>
            <strong>UV Coordinates:</strong> Setiap vertex memiliki koordinat
            texture (0.0 - 1.0)
          </li>
          <li>
            <strong>Sampler2D:</strong> Fragment shader menggunakan texture2D()
            untuk sampling
          </li>
          <li>
            <strong>Procedural Texture:</strong> Texture dibuat dari array data
            (checkerboard pattern)
          </li>
        </ul>
      </div>
    </div>

    <script>
      // Vertex Shader
      const vsSource = `
            attribute vec3 aVertexPosition;
            attribute vec2 aTextureCoord;
            
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            
            varying highp vec2 vTextureCoord;
            
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
                vTextureCoord = aTextureCoord;
            }
        `;

      // Fragment Shader
      const fsSource = `
            precision mediump float;
            
            varying highp vec2 vTextureCoord;
            uniform sampler2D uSampler;
            
            void main() {
                gl_FragColor = texture2D(uSampler, vTextureCoord);
            }
        `;

      let rotation = 0;

      function main() {
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");

        if (!gl) {
          alert("WebGL tidak tersedia di browser Anda!");
          return;
        }

        // Compile shaders
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        // Create program
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Program linking failed: " + gl.getProgramInfoLog(shaderProgram)
          );
          return;
        }

        const programInfo = {
          program: shaderProgram,
          attribLocations: {
            vertexPosition: gl.getAttribLocation(
              shaderProgram,
              "aVertexPosition"
            ),
            textureCoord: gl.getAttribLocation(shaderProgram, "aTextureCoord"),
          },
          uniformLocations: {
            projectionMatrix: gl.getUniformLocation(
              shaderProgram,
              "uProjectionMatrix"
            ),
            modelViewMatrix: gl.getUniformLocation(
              shaderProgram,
              "uModelViewMatrix"
            ),
            uSampler: gl.getUniformLocation(shaderProgram, "uSampler"),
          },
        };

        const buffers = initBuffers(gl);
        const texture = createProceduralTexture(gl);

        document.getElementById("status").textContent =
          "âœ“ Texture loaded successfully!";

        function render() {
          drawScene(gl, programInfo, buffers, texture);
          rotation += 0.01;
          requestAnimationFrame(render);
        }
        render();
      }

      function initBuffers(gl) {
        // Cube vertices
        const positions = [
          // Front face
          -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
          // Back face
          -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0,
          // Top face
          -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0,
          // Bottom face
          -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
          // Right face
          1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
          // Left face
          -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,
        ];

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(positions),
          gl.STATIC_DRAW
        );

        // Texture coordinates
        const textureCoordinates = [
          // Front
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
          // Back
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
          // Top
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
          // Bottom
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
          // Right
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
          // Left
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
        ];

        const textureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(textureCoordinates),
          gl.STATIC_DRAW
        );

        // Indices
        const indices = [
          0,
          1,
          2,
          0,
          2,
          3, // front
          4,
          5,
          6,
          4,
          6,
          7, // back
          8,
          9,
          10,
          8,
          10,
          11, // top
          12,
          13,
          14,
          12,
          14,
          15, // bottom
          16,
          17,
          18,
          16,
          18,
          19, // right
          20,
          21,
          22,
          20,
          22,
          23, // left
        ];

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indices),
          gl.STATIC_DRAW
        );

        return {
          position: positionBuffer,
          textureCoord: textureCoordBuffer,
          indices: indexBuffer,
        };
      }

      function createProceduralTexture(gl) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Create checkerboard pattern
        const width = 64;
        const height = 64;
        const pixels = new Uint8Array(width * height * 4);

        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const index = (i * width + j) * 4;
            const checker = ((i >> 3) + (j >> 3)) & 1;

            if (checker) {
              // Blue
              pixels[index] = 100;
              pixels[index + 1] = 150;
              pixels[index + 2] = 255;
            } else {
              // White
              pixels[index] = 255;
              pixels[index + 1] = 255;
              pixels[index + 2] = 255;
            }
            pixels[index + 3] = 255; // Alpha
          }
        }

        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(
          gl.TEXTURE_2D,
          gl.TEXTURE_MIN_FILTER,
          gl.LINEAR_MIPMAP_LINEAR
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        return texture;
      }

      function drawScene(gl, programInfo, buffers, texture) {
        gl.clearColor(0.95, 0.95, 0.97, 1.0);
        gl.clearDepth(1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Projection matrix
        const projectionMatrix = mat4_perspective(
          (45 * Math.PI) / 180,
          1.0,
          0.1,
          100.0
        );

        // Model-view matrix
        const modelViewMatrix = mat4_create();
        mat4_translate(modelViewMatrix, [0.0, 0.0, -6.0]);
        mat4_rotateX(modelViewMatrix, rotation);
        mat4_rotateY(modelViewMatrix, rotation * 0.7);
        mat4_rotateZ(modelViewMatrix, rotation * 0.3);

        // Bind position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          programInfo.attribLocations.vertexPosition,
          3,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        // Bind texture coordinate buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
        gl.vertexAttribPointer(
          programInfo.attribLocations.textureCoord,
          2,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);

        // Bind indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

        // Use program
        gl.useProgram(programInfo.program);

        // Set uniforms
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix
        );
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix
        );

        // Bind texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(programInfo.uniformLocations.uSampler, 0);

        // Draw
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
      }

      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert("Shader compile error: " + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // Simple matrix math functions
      function mat4_create() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      function mat4_perspective(fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy / 2);
        const nf = 1 / (near - far);
        return [
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0,
        ];
      }

      function mat4_translate(m, v) {
        m[12] += v[0];
        m[13] += v[1];
        m[14] += v[2];
      }

      function mat4_rotateX(m, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const m4 = m[4],
          m5 = m[5],
          m6 = m[6],
          m7 = m[7];
        const m8 = m[8],
          m9 = m[9],
          m10 = m[10],
          m11 = m[11];
        m[4] = m4 * c + m8 * s;
        m[5] = m5 * c + m9 * s;
        m[6] = m6 * c + m10 * s;
        m[7] = m7 * c + m11 * s;
        m[8] = m8 * c - m4 * s;
        m[9] = m9 * c - m5 * s;
        m[10] = m10 * c - m6 * s;
        m[11] = m11 * c - m7 * s;
      }

      function mat4_rotateY(m, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const m0 = m[0],
          m1 = m[1],
          m2 = m[2],
          m3 = m[3];
        const m8 = m[8],
          m9 = m[9],
          m10 = m[10],
          m11 = m[11];
        m[0] = m0 * c - m8 * s;
        m[1] = m1 * c - m9 * s;
        m[2] = m2 * c - m10 * s;
        m[3] = m3 * c - m11 * s;
        m[8] = m0 * s + m8 * c;
        m[9] = m1 * s + m9 * c;
        m[10] = m2 * s + m10 * c;
        m[11] = m3 * s + m11 * c;
      }

      function mat4_rotateZ(m, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const m0 = m[0],
          m1 = m[1],
          m2 = m[2],
          m3 = m[3];
        const m4 = m[4],
          m5 = m[5],
          m6 = m[6],
          m7 = m[7];
        m[0] = m0 * c + m4 * s;
        m[1] = m1 * c + m5 * s;
        m[2] = m2 * c + m6 * s;
        m[3] = m3 * c + m7 * s;
        m[4] = m4 * c - m0 * s;
        m[5] = m5 * c - m1 * s;
        m[6] = m6 * c - m2 * s;
        m[7] = m7 * c - m3 * s;
      }

      window.onload = main;
    </script>
  </body>
</html>
